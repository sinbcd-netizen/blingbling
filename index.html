<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Immersive Hand-Controlled Particle System</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: white;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Video is hidden, processed in background */
        #input-video {
            display: none;
        }

        /* UI Overlay */
        #ui-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 280px;
            background: rgba(20, 20, 30, 0.6);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 10;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            transition: opacity 0.3s;
        }

        h2 {
            margin: 0 0 15px 0;
            font-size: 16px;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: #4facfe;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 10px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            font-size: 12px;
            margin-bottom: 5px;
            color: #aaa;
        }

        input[type="range"] {
            width: 100%;
            background: transparent;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #4facfe;
            margin-top: -6px;
            cursor: pointer;
        }

        input[type="color"] {
            width: 100%;
            border: none;
            height: 30px;
            cursor: pointer;
            background: none;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        button {
            flex: 1;
            padding: 8px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        button:hover, button.active {
            background: #4facfe;
            border-color: #4facfe;
            color: #000;
        }

        #status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 10;
            font-size: 12px;
            color: #aaa;
            pointer-events: none;
        }
        
        .loading {
            color: #ff9800;
        }
        .ready {
            color: #4caf50;
        }

        #draw-instruction {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            text-align: center;
            z-index: 5;
            background: rgba(0,0,0,0.5);
            padding: 20px;
            border-radius: 10px;
        }
    </style>
</head>
<body>

    <!-- 隐藏的视频元素用于 MediaPipe -->
    <video id="input-video" playsinline></video>

    <!-- WebGL 画布 -->
    <div id="canvas-container"></div>

    <!-- UI 面板 -->
    <div id="ui-container">
        <h2>粒子控制中心</h2>
        
        <div class="control-group">
            <label>模型预设</label>
            <div class="btn-group">
                <button id="btn-nebula" class="active">星云</button>
                <button id="btn-heart">爱心</button>
                <button id="btn-draw">手绘</button>
            </div>
        </div>

        <div class="control-group">
            <label>粒子颜色</label>
            <input type="color" id="color-picker" value="#00ffff">
        </div>

        <div class="control-group">
            <label>粒子密度 (Count)</label>
            <input type="range" id="density-slider" min="5000" max="30000" step="1000" value="15000">
        </div>

        <div class="control-group">
            <label>最大扩散度 (Spread)</label>
            <input type="range" id="spread-slider" min="0.5" max="5.0" step="0.1" value="2.0">
        </div>
        
        <div class="control-group" style="border-top: 1px solid rgba(255,255,255,0.1); padding-top:10px;">
            <label>手部状态监测</label>
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <span id="hand-state-text">未检测</span>
                <div style="width: 100px; height: 6px; background: #333; border-radius: 3px; overflow: hidden;">
                    <div id="hand-strength-bar" style="width: 0%; height: 100%; background: #4facfe; transition: width 0.1s;"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="status">系统初始化中...</div>
    <div id="draw-instruction">按住鼠标左键并在屏幕上绘制图案</div>

    <!-- 脚本引入 -->
    <!-- Three.js -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.154.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.154.0/examples/jsm/"
            }
        }
    </script>
    
    <!-- MediaPipe (Using Global Scripts for simplicity in single file mixed env) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 全局变量与配置 ---
        const config = {
            particleCount: 15000,
            baseColor: new THREE.Color(0x00ffff),
            maxSpread: 2.0,
            handOpenness: 0, // 0: 握拳, 1: 张开
            currentShape: 'nebula', // nebula, heart, drawing
            drawPoints: [] 
        };

        let scene, camera, renderer, controls, clock;
        let particles, particleGeometry, particleMaterial;
        let bgParticles;
        let targetPositions = []; // 存储目标形状的位置数据
        
        // 射线检测用于绘图
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const drawPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
        let isDrawing = false;

        // --- 初始化 Three.js ---
        function initThree() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            clock = new THREE.Clock();

            // 灯光 (虽然主要靠发光粒子，但加点环境光)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            // 初始化背景
            initBackground();

            // 初始化主粒子系统
            initParticles();

            // 事件监听
            window.addEventListener('resize', onWindowResize);
            
            // 绘图事件
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);

            animate();
        }

        // --- 背景星空 ---
        function initBackground() {
            const bgCount = 2000;
            const bgGeo = new THREE.BufferGeometry();
            const bgPos = new Float32Array(bgCount * 3);
            
            for(let i=0; i<bgCount*3; i++) {
                bgPos[i] = (Math.random() - 0.5) * 40;
            }
            bgGeo.setAttribute('position', new THREE.BufferAttribute(bgPos, 3));
            
            const bgMat = new THREE.PointsMaterial({
                size: 0.05,
                color: 0x888888,
                transparent: true,
                opacity: 0.6,
                sizeAttenuation: true
            });

            bgParticles = new THREE.Points(bgGeo, bgMat);
            scene.add(bgParticles);
        }

        // --- 主粒子系统 (使用 ShaderMaterial 获得更棒的效果) ---
        function initParticles() {
            if (particles) scene.remove(particles);

            particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(config.particleCount * 3);
            const targets = new Float32Array(config.particleCount * 3);
            const randomness = new Float32Array(config.particleCount * 3);
            const sizes = new Float32Array(config.particleCount);

            // 初始化位置和随机值
            for (let i = 0; i < config.particleCount; i++) {
                const i3 = i * 3;
                positions[i3] = (Math.random() - 0.5) * 10;
                positions[i3 + 1] = (Math.random() - 0.5) * 10;
                positions[i3 + 2] = (Math.random() - 0.5) * 10;
                
                randomness[i3] = (Math.random() - 0.5);
                randomness[i3 + 1] = (Math.random() - 0.5);
                randomness[i3 + 2] = (Math.random() - 0.5);

                sizes[i] = Math.random();
            }

            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            // 我们不把 target 传给 shader，而是在 CPU 端计算混合位置以实现复杂的"手势控制"，
            // 然后更新 position attribute。这样更容易做物理效果。
            
            // 辅助数据存储在 userData
            particleGeometry.userData = {
                targets: targets,
                randomness: randomness,
                baseSizes: sizes
            };

            // 自定义 Shader 模拟发光粒子
            particleMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    color: { value: config.baseColor },
                    pointTexture: { value: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/spark1.png') }
                },
                vertexShader: `
                    attribute float size;
                    varying vec3 vColor;
                    void main() {
                        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
                        gl_PointSize = size * ( 300.0 / -mvPosition.z );
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    uniform sampler2D pointTexture;
                    void main() {
                        gl_FragColor = vec4( color, 1.0 );
                        gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );
                    }
                `,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true
            });

            particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);

            // 初始形状
            updateTargetShape(config.currentShape);
        }

        // --- 形状生成逻辑 ---
        function updateTargetShape(shapeType) {
            const targets = particleGeometry.userData.targets;
            const count = config.particleCount;

            if (shapeType === 'nebula') {
                for (let i = 0; i < count; i++) {
                    const i3 = i * 3;
                    // 球体分布
                    const r = 2 * Math.cbrt(Math.random());
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    targets[i3] = r * Math.sin(phi) * Math.cos(theta);
                    targets[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                    targets[i3 + 2] = r * Math.cos(phi);
                }
            } else if (shapeType === 'heart') {
                for (let i = 0; i < count; i++) {
                    const i3 = i * 3;
                    // 心形公式
                    // x = 16sin^3(t)
                    // y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
                    const t = Math.random() * Math.PI * 2;
                    // 加点随机厚度
                    const thickness = (Math.random() - 0.5) * 0.5; 
                    
                    const x = 16 * Math.pow(Math.sin(t), 3);
                    const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    
                    // 缩放一下
                    targets[i3] = x * 0.1 + thickness;
                    targets[i3 + 1] = y * 0.1 + thickness;
                    targets[i3 + 2] = thickness * 4; // z轴厚度
                }
            } else if (shapeType === 'drawing') {
                // 如果没有绘图数据，先用星云代替，否则映射绘图点
                if (config.drawPoints.length === 0) {
                    updateTargetShape('nebula'); 
                    return;
                }
                
                for (let i = 0; i < count; i++) {
                    const i3 = i * 3;
                    // 取模循环利用绘图点
                    const pIndex = i % config.drawPoints.length;
                    const p = config.drawPoints[pIndex];
                    
                    // 加一点点随机抖动，让线条看起来像发光带
                    targets[i3] = p.x + (Math.random()-0.5)*0.1;
                    targets[i3 + 1] = p.y + (Math.random()-0.5)*0.1;
                    targets[i3 + 2] = p.z + (Math.random()-0.5)*0.1;
                }
            }
        }

        // --- 核心动画循环 ---
        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();
            const delta = clock.getDelta();

            // 1. 背景微动
            if (bgParticles) {
                bgParticles.rotation.y = time * 0.05;
            }

            // 2. 主粒子更新
            if (particles) {
                const positions = particleGeometry.attributes.position.array;
                const targets = particleGeometry.userData.targets;
                const randomness = particleGeometry.userData.randomness;
                const sizes = particleGeometry.attributes.size.array;
                const baseSizes = particleGeometry.userData.baseSizes;

                // 扩散系数：手张开越大，系数越大
                // 基础扩散 + 手势带来的爆发扩散
                let dispersion = config.handOpenness * config.maxSpread; 
                // 如果在绘图模式，不希望手势把图全打散，稍微保留一点形态
                if (config.currentShape === 'drawing') dispersion *= 0.5;

                // Lerp 速度：越小越平滑
                const lerpFactor = 0.05;

                for (let i = 0; i < config.particleCount; i++) {
                    const i3 = i * 3;

                    // 计算目标位置（加上手势带来的噪音扩散）
                    // 噪音基于 randomness 数组和 时间正弦波
                    const noiseX = randomness[i3] * dispersion * (Math.sin(time + i) + 1.5);
                    const noiseY = randomness[i3 + 1] * dispersion * (Math.cos(time + i*0.5) + 1.5);
                    const noiseZ = randomness[i3 + 2] * dispersion * Math.sin(time * 0.5);

                    const tx = targets[i3] + noiseX;
                    const ty = targets[i3 + 1] + noiseY;
                    const tz = targets[i3 + 2] + noiseZ;

                    // 插值移动
                    positions[i3] += (tx - positions[i3]) * lerpFactor;
                    positions[i3 + 1] += (ty - positions[i3 + 1]) * lerpFactor;
                    positions[i3 + 2] += (tz - positions[i3 + 2]) * lerpFactor;

                    // 呼吸灯大小效果
                    sizes[i] = baseSizes[i] * (0.8 + 0.4 * Math.sin(time * 2 + i));
                    // 扩散时粒子变大一点点
                    sizes[i] += config.handOpenness * 0.5 * Math.random();
                }

                particleGeometry.attributes.position.needsUpdate = true;
                particleGeometry.attributes.size.needsUpdate = true;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // --- 交互处理 ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // 绘图模式逻辑
        function onMouseDown(e) {
            if (config.currentShape !== 'drawing') return;
            isDrawing = true;
            config.drawPoints = []; // 清空旧图
            document.getElementById('draw-instruction').style.display = 'none';
        }
        
        function onMouseMove(e) {
            if (!isDrawing || config.currentShape !== 'drawing') return;
            
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersectPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(drawPlane, intersectPoint);
            
            if (intersectPoint) {
                config.drawPoints.push(intersectPoint.clone());
            }
        }

        function onMouseUp() {
            if (isDrawing) {
                isDrawing = false;
                // 更新粒子目标
                if (config.drawPoints.length > 0) {
                    updateTargetShape('drawing');
                }
            }
        }


        // --- UI 逻辑绑定 ---
        document.getElementById('btn-nebula').addEventListener('click', (e) => {
            setActiveBtn(e.target);
            config.currentShape = 'nebula';
            updateTargetShape('nebula');
            document.getElementById('draw-instruction').style.display = 'none';
        });

        document.getElementById('btn-heart').addEventListener('click', (e) => {
            setActiveBtn(e.target);
            config.currentShape = 'heart';
            updateTargetShape('heart');
            document.getElementById('draw-instruction').style.display = 'none';
        });

        document.getElementById('btn-draw').addEventListener('click', (e) => {
            setActiveBtn(e.target);
            config.currentShape = 'drawing';
            config.drawPoints = []; // Reset
            updateTargetShape('drawing'); // Will default to nebula temporarily
            document.getElementById('draw-instruction').style.display = 'block';
            
            // 调整相机看平面
            controls.reset();
        });

        function setActiveBtn(target) {
            document.querySelectorAll('.btn-group button').forEach(b => b.classList.remove('active'));
            target.classList.add('active');
        }

        document.getElementById('color-picker').addEventListener('input', (e) => {
            config.baseColor.set(e.target.value);
            if(particleMaterial) particleMaterial.uniforms.color.value = config.baseColor;
        });

        document.getElementById('density-slider').addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            config.particleCount = val;
            initParticles(); // 重建系统
        });

        document.getElementById('spread-slider').addEventListener('input', (e) => {
            config.maxSpread = parseFloat(e.target.value);
        });


        // --- MediaPipe 逻辑 ---
        const videoElement = document.getElementById('input-video');
        const statusElement = document.getElementById('status');
        const handStrengthBar = document.getElementById('hand-strength-bar');
        const handStateText = document.getElementById('hand-state-text');

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // 关键点: 0(手腕), 4(拇指尖), 8(食指尖), 12(中指尖)
                // 计算拇指尖(4)与食指尖(8)的距离作为"张合"依据
                
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const middleTip = landmarks[12];
                const wrist = landmarks[0];

                // 简单的欧几里得距离 (2D投影，z也可以考虑但2d足够稳定)
                // 计算距离相对于手掌大小的比例，以适应不同距离的手
                
                // 手掌参考大小 (手腕到中指根部 0 -> 9)
                const palmBase = landmarks[0];
                const middleBase = landmarks[9];
                const palmSize = Math.hypot(palmBase.x - middleBase.x, palmBase.y - middleBase.y);

                // 拇指到食指距离
                const fingerDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
                
                // 归一化 Openness (大致范围调试得出，通常指尖并拢dist接近0，张开可达palmSize的1.5倍左右)
                let openness = fingerDist / (palmSize * 1.2);
                openness = Math.max(0, Math.min(1, openness)); // Clamp 0-1

                // 平滑处理
                config.handOpenness = config.handOpenness * 0.8 + openness * 0.2;

                // UI 更新
                handStrengthBar.style.width = `${config.handOpenness * 100}%`;
                
                if (config.handOpenness < 0.2) {
                    handStateText.innerText = "聚合 (Closed)";
                    handStateText.style.color = "#ff4444";
                } else if (config.handOpenness > 0.6) {
                    handStateText.innerText = "扩散 (Open)";
                    handStateText.style.color = "#4caf50";
                } else {
                    handStateText.innerText = "调整中...";
                    handStateText.style.color = "#fff";
                }

                statusElement.innerText = "系统运行正常 - 捕捉手部中";
                statusElement.className = "ready";

            } else {
                // 没检测到手，慢慢恢复到默认状态（比如半开或闭合）
                config.handOpenness = config.handOpenness * 0.95;
                handStrengthBar.style.width = '0%';
                handStateText.innerText = "未检测";
                handStateText.style.color = "#777";
                statusElement.innerText = "等待手部进入视野...";
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // 启动摄像头
        async function startCamera() {
            try {
                const cameraUtils = new Camera(videoElement, {
                    onFrame: async () => {
                        await hands.send({image: videoElement});
                    },
                    width: 640,
                    height: 480
                });
                cameraUtils.start();
                statusElement.innerText = "摄像头启动中...";
                statusElement.className = "loading";
            } catch (e) {
                console.error(e);
                statusElement.innerText = "摄像头错误: 请检查权限或HTTPS环境";
                statusElement.style.color = "red";
            }
        }

        // 启动程序
        initThree();
        startCamera();

    </script>
</body>
</html>